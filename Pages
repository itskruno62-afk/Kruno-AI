import React, { useState, useEffect, useRef, useCallback } from "react";
import { Conversation } from "@/entities/Conversation";
import { InvokeLLM, GenerateImage } from "@/integrations/Core";
import { motion, AnimatePresence } from "framer-motion";
import { Bot } from "lucide-react";

import MessageBubble from "../components/chat/MessageBubble";
import ConversationList from "../components/chat/ConversationList";
import ChatInput from "../components/chat/ChatInput";

export default function Chat() {
  const [conversations, setConversations] = useState([]);
  const [currentConversation, setCurrentConversation] = useState(null);
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [aiMode, setAiMode] = useState("casual");
  const messagesEndRef = useRef(null);

  const selectConversation = useCallback((id, convs) => {
    const conversation = convs.find(c => c.id === id);
    if (conversation) {
      setCurrentConversation(conversation);
      setMessages(conversation.messages || []);
      setAiMode(conversation.ai_mode);
    }
  }, []);

  useEffect(() => {
    let isMounted = true;
    const loadInitialConversations = async () => {
      try {
        const data = await Conversation.list('-last_activity');
        if (isMounted) {
          setConversations(data);
          if (!currentConversation && data.length > 0) {
            selectConversation(data[0].id, data);
          }
        }
      } catch (error) {
        console.error("Failed to load conversations:", error);
      }
    };

    loadInitialConversations();

    return () => {
      isMounted = false;
    };
  }, [selectConversation, currentConversation]);

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  const createNewConversation = async () => {
    const newConversation = await Conversation.create({
      title: "New Chat",
      ai_mode: aiMode,
      messages: [],
      last_activity: new Date().toISOString()
    });
    
    setConversations(prev => [newConversation, ...prev]);
    setCurrentConversation(newConversation);
    setMessages([]);
  };

  const updateConversation = async (newMessages) => {
    if (!currentConversation) return;
    
    const title = newMessages.length > 1 ? 
      newMessages[0].content.substring(0, 50) + (newMessages[0].content.length > 50 ? '...' : '') :
      'New Chat';

    const updatedConversation = {
      ...currentConversation,
      title,
      messages: newMessages,
      ai_mode: aiMode,
      last_activity: new Date().toISOString()
    };
    
    await Conversation.update(currentConversation.id, updatedConversation);
    setCurrentConversation(updatedConversation);
    
    setConversations(prev => {
        const otherConversations = prev.filter(c => c.id !== currentConversation.id);
        return [updatedConversation, ...otherConversations].sort((a, b) => new Date(b.last_activity) - new Date(a.last_activity));
    });
  };

  const getModePrompt = (mode) => {
    const prompts = {
      creative: "Respond in a creative, imaginative way. Be artistic and think outside the box.",
      professional: "Respond in a professional, business-appropriate manner. Be formal and precise.",
      casual: "Respond in a friendly, casual way. Be conversational and approachable.",
      technical: "Respond with technical accuracy and detail. Use precise terminology and be thorough."
    };
    return prompts[mode] || prompts.casual;
  };

  const sendMessage = async (content) => {
    if (isLoading) return;

    let conv = currentConversation;
    if (!conv) {
      conv = await Conversation.create({
        title: "New Chat",
        ai_mode: aiMode,
        messages: [],
        last_activity: new Date().toISOString()
      });
      setConversations(prev => [conv, ...prev]);
      setCurrentConversation(conv);
      setMessages([]);
    }

    const userMessage = {
      role: "user",
      content,
      timestamp: new Date().toISOString(),
      type: "text"
    };

    const newMessages = [...(conv.messages || []), userMessage];
    setMessages(newMessages);
    setIsLoading(true);

    try {
      const conversationHistory = newMessages.slice(-10).map(m => ({
        role: m.role,
        content: m.content
      }));

      const response = await InvokeLLM({
        prompt: `${getModePrompt(aiMode)}\n\nConversation history:\n${conversationHistory.map(m => `${m.role}: ${m.content}`).join('\n')}\n\nUser: ${content}\n\nAssistant:`,
      });

      const assistantMessage = {
        role: "assistant",
        content: response,
        timestamp: new Date().toISOString(),
        type: "text"
      };

      const finalMessages = [...newMessages, assistantMessage];
      setMessages(finalMessages);
      await updateConversation(finalMessages);
    } catch (error) {
      console.error("Error sending message:", error);
       const errorMessage = {
        role: "assistant",
        content: "Sorry, I encountered an error. Please try again.",
        timestamp: new Date().toISOString(),
        type: "text"
      };
      setMessages(prev => [...prev, errorMessage]);
    }

    setIsLoading(false);
  };

  const generateImage = async (prompt) => {
     if (isLoading) return;

    let conv = currentConversation;
    if (!conv) {
      conv = await Conversation.create({
        title: "New Chat",
        ai_mode: aiMode,
        messages: [],
        last_activity: new Date().toISOString()
      });
      setConversations(prev => [conv, ...prev]);
      setCurrentConversation(conv);
      setMessages([]);
    }

    const userMessage = {
      role: "user",
      content: `Generate image: ${prompt}`,
      timestamp: new Date().toISOString(),
      type: "text"
    };

    const newMessages = [...(conv.messages || []), userMessage];
    setMessages(newMessages);
    setIsLoading(true);

    try {
      const result = await GenerateImage({ prompt });

      const assistantMessage = {
        role: "assistant",
        content: "Here's your generated image:",
        timestamp: new Date().toISOString(),
        type: "image",
        image_url: result.url
      };

      const finalMessages = [...newMessages, assistantMessage];
      setMessages(finalMessages);
      await updateConversation(finalMessages);
    } catch (error) {
      console.error("Error generating image:", error);
      const errorMessage = {
        role: "assistant",
        content: "Sorry, I couldn't generate the image. Please try again.",
        timestamp: new Date().toISOString(),
        type: "text"
      };
      setMessages(prev => [...prev, errorMessage]);
    }

    setIsLoading(false);
  };

  const deleteConversation = async (id) => {
    await Conversation.delete(id);
    const remainingConvs = conversations.filter(c => c.id !== id);
    setConversations(remainingConvs);
    
    if (currentConversation?.id === id) {
      if (remainingConvs.length > 0) {
        selectConversation(remainingConvs[0].id, remainingConvs);
      } else {
        setCurrentConversation(null);
        setMessages([]);
      }
    }
  };

  return (
    <div className="flex h-full bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50">
      <div className="w-80 bg-white/60 backdrop-blur-sm border-r border-white/20 p-6 overflow-y-auto hidden md:block">
        <ConversationList
          conversations={conversations}
          selectedId={currentConversation?.id}
          onSelect={(id) => selectConversation(id, conversations)}
          onNewConversation={createNewConversation}
          onDelete={deleteConversation}
        />
      </div>

      <div className="flex-1 flex flex-col min-w-0">
        <div className="flex-1 overflow-y-auto p-6">
          <div className="max-w-4xl mx-auto">
            {!currentConversation ? (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                className="text-center py-20"
              >
                <div className="w-20 h-20 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center mx-auto mb-6 shadow-xl">
                  <span className="text-white font-bold text-2xl">AI</span>
                </div>
                <h2 className="text-3xl font-bold text-slate-700 mb-4">
                  Welcome to your AI Assistant
                </h2>
                <p className="text-slate-500 text-lg max-w-md mx-auto">
                  Select a chat on the left or create a new one to get started.
                </p>
              </motion.div>
            ) : (
              <AnimatePresence>
                {messages.map((message, index) => (
                  <MessageBubble
                    key={index}
                    message={message}
                    isUser={message.role === 'user'}
                  />
                ))}
              </AnimatePresence>
            )}
            
            {isLoading && (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                className="flex justify-start mb-6"
              >
                 <div className="w-10 h-10 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center shadow-lg flex-shrink-0">
                    <Bot className="w-5 h-5 text-white" />
                </div>
                <div className="ml-4 bg-white/80 backdrop-blur-sm rounded-3xl px-6 py-4 border border-white/20 shadow-sm">
                  <div className="flex gap-2 items-center">
                    <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce"></div>
                    <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                    <div className="w-2 h-2 bg-blue-400 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                  </div>
                </div>
              </motion.div>
            )}
            
            <div ref={messagesEndRef} />
          </div>
        </div>

        <ChatInput
          onSendMessage={sendMessage}
          onGenerateImage={generateImage}
          isLoading={isLoading}
          aiMode={aiMode}
          onModeChange={setAiMode}
        />
      </div>
    </div>
  );
}
